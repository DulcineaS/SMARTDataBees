//	============================================================================
//
//  .,-:::::   :::.    :::::::..   :::::::.      ...   :::.    :::.
//	,;;;'````'   ;;`;;   ;;;;``;;;;   ;;;'';;'  .;;;;;;;.`;;;;,  `;;;
//	[[[         ,[[ '[[,  [[[,/[[['   [[[__[[\.,[[     \[[,[[[[[. '[[
//	$$$        c$$$cc$$$c $$$$$$c     $$""""Y$$$$$,     $$$$$$ "Y$c$$
//	`88bo,__,o, 888   888,888b "88bo,_88o,,od8P"888,_ _,88P888    Y88
//	"YUMMMMMP"YMM   ""` MMMM   "W" ""YUMMMP"   "YMMMMMP" MMM     YM
//
//	============================================================================
//
//	This file is a part of the Carbon Framework.
//
//	Copyright (C) 2005 Mark (Code6) Belles 
//
//	This library is free software; you can redistribute it and/or
//	modify it under the terms of the GNU Lesser General Public
//	License as published by the Free Software Foundation; either
//	version 2.1 of the License, or (at your option) any later version.
//
//	This library is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//	Lesser General Public License for more details.
//
//	You should have received a copy of the GNU Lesser General Public
//	License along with this library; if not, write to the Free Software
//	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//	============================================================================

using System;
using System.Diagnostics;
using Carbon.Common;

namespace Carbon.MultiThreading
{
	/// <summary>
	/// Provides a strongly-typed collection of BackgroundThread instances.
	/// This class is thread safe.
	/// </summary>
	[DebuggerStepThrough]
	public sealed class BackgroundThreadCollection : DisposableCollection
	{
		#region BackgroundThreadAlreadyExistsException

		/// <summary>
		/// Defines an exception that is generated by the BackgroundThreadCollection if a
		/// BackgroundThread is added to the collection that already exists in the collection.
		/// </summary>
		public sealed class BackgroundThreadAlreadyExistsException : ApplicationException
		{
			private readonly BackgroundThread _thread;

			/// <summary>
			/// Initializes a new instance of the BackgroundThreadAlreadyExistsException class
			/// </summary>
			/// <param name="thread">The thread that already exists in the collection</param>
			internal BackgroundThreadAlreadyExistsException(BackgroundThread thread) : 
				base("The background thread already exists in the collection.")
			{
				_thread = thread;
			}

			/// <summary>
			/// Returns the thread that already exists in the collection
			/// </summary>
			public BackgroundThread Thread
			{
				get
				{
					return _thread;
				}
			}
		}

		#endregion

		/// <summary>
		/// This operator allows a list to be explicitly cast to an array of it's contents
		/// </summary>
		/// <example>
		/// BackgroundThreadCollection list = new BackgroundThreadCollection();
		/// BackgroundThread[] threads = (BackgroundThread[])list;
		/// </example>
		/// <param name="list"></param>
		/// <returns></returns>
		public static explicit operator BackgroundThread[] (BackgroundThreadCollection list)
		{
			if (list == null)
				throw new ArgumentNullException("list");

			return list.InnerList.ToArray(typeof(BackgroundThread)) as BackgroundThread[];
		}

	    /// <summary>
		/// Adds a thread to the collection
		/// </summary>
		/// <param name="thread">The thread to add</param>
		public void Add(BackgroundThread thread)
		{
			if (Contains(thread))
				throw new BackgroundThreadAlreadyExistsException(thread);
			
			lock (SyncRoot)
			{
				InnerList.Add(thread);
			}
		}

		/// <summary>
		/// Removes a thread from the collection
		/// </summary>
		/// <param name="thread">The thread to remove</param>
		public void Remove(BackgroundThread thread)
		{
			if (Contains(thread))
				lock (SyncRoot)
				{
					InnerList.Remove(thread);
				}
		}

//		/// <summary>
//		/// Removes the thread at the specified index
//		/// </summary>
//		/// <param name="index">The index of the thread to remove</param>
//		public void RemoveAt(int index)
//		{
//			lock (base.SyncRoot)
//			{
//				base.InnerList.RemoveAt(index);
//			}
//		}

		/// <summary>
		/// Determines if the collection contains the thread
		/// </summary>
		/// <param name="thread">The thread to look for</param>
		/// <returns></returns>
		public bool Contains(BackgroundThread thread)
		{
			if (thread == null)
				throw new ArgumentNullException("thread");
			
			lock (SyncRoot)
			{
				foreach(BackgroundThread t in InnerList)
					if (Equals(t, thread))
						return true;
				return false;
			}
		}

		/// <summary>
		/// Returns the BackgroundThread at the specified index
		/// </summary>
		public BackgroundThread this[int index]
		{
			get
			{
				lock (SyncRoot)
				{
					return InnerList[index] as BackgroundThread;
				}
			}
		}
	}
}
