//	============================================================================
//
//  .,-:::::   :::.    :::::::..   :::::::.      ...   :::.    :::.
//	,;;;'````'   ;;`;;   ;;;;``;;;;   ;;;'';;'  .;;;;;;;.`;;;;,  `;;;
//	[[[         ,[[ '[[,  [[[,/[[['   [[[__[[\.,[[     \[[,[[[[[. '[[
//	$$$        c$$$cc$$$c $$$$$$c     $$""""Y$$$$$,     $$$$$$ "Y$c$$
//	`88bo,__,o, 888   888,888b "88bo,_88o,,od8P"888,_ _,88P888    Y88
//	"YUMMMMMP"YMM   ""` MMMM   "W" ""YUMMMP"   "YMMMMMP" MMM     YM
//
//	============================================================================
//
//	This file is a part of the Carbon Framework.
//
//	Copyright (C) 2005 Mark (Code6) Belles 
//
//	This library is free software; you can redistribute it and/or
//	modify it under the terms of the GNU Lesser General Public
//	License as published by the Free Software Foundation; either
//	version 2.1 of the License, or (at your option) any later version.
//
//	This library is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//	Lesser General Public License for more details.
//
//	You should have received a copy of the GNU Lesser General Public
//	License along with this library; if not, write to the Free Software
//	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//	============================================================================

using System;
using System.Collections;

using Carbon.Common;

namespace Carbon.Plugins
{
	/// <summary>
	/// Provides a strongly-typed collection of PluginDescriptor instances.
	/// This class is thread safe.
	/// </summary>
//	[System.Diagnostics.DebuggerStepThrough()]
	public sealed class PluginDescriptorCollection : DisposableCollection
	{
		#region PluginDescriptorAlreadyExistsException

		/// <summary>
		/// Defines an Exception that is generated by the PluginDescriptorCollection when a PluginDescriptor
		/// is added to the collection for a Type when another PluginDescriptor already exists in the collection for the same Type.
		/// </summary>
		public sealed class PluginDescriptorAlreadyExistsException : ApplicationException
		{
			private readonly PluginDescriptor _descriptor;

			internal PluginDescriptorAlreadyExistsException(PluginDescriptor descriptor) : 
				base(string.Format("The PluginDescriptor '{0}' already exists in the collection.", descriptor.ToString()))
			{
				_descriptor = descriptor;
			}

			public PluginDescriptor PluginDescriptor
			{
				get
				{
					return _descriptor;
				}
			}
		}
		
		#endregion

        #region LeastDependentComparer

        /// <summary>
        /// Defines an IComparer implementation that sorts PluginDescriptor instances,
        /// placing the least dependent descriptors first in the collection.
        /// </summary>
        private sealed class LeastDependentComparer : IComparer
        {
            /// <summary>
            /// Initializes a new instance of the LeastDependentComparer class
            /// </summary>
            public LeastDependentComparer()
            {

            }

            #region IComparer Members

            /// <summary>
            /// Compares two PluginDescriptor instances.
            /// </summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <returns></returns>
            public int Compare(object x, object y)
            {
                PluginDescriptor xDescriptor = (PluginDescriptor)x;
                PluginDescriptor yDescriptor = (PluginDescriptor)y;

				//Log.WriteLine(xDescriptor.ToString() + " == " + yDescriptor.ToString());
                
                if (xDescriptor == yDescriptor)
                    return 0;

                // the opposite of the MostDependentComparer class
                bool xDependsOnY = xDescriptor.DependsOn(yDescriptor);
                bool yDependsOnX = yDescriptor.DependsOn(xDescriptor);

                if (xDependsOnY)
                    return 1;
                else if (yDependsOnX)
                    return -1;
                else
                    return 0;
            }

            #endregion
        }

        #endregion

        #region MostDependentComparer

        /// <summary>
        /// Defines an IComparer implementation that sorts PluginDescriptor instances,
        /// placing the most dependent descriptors first in the collection.
        /// </summary>
        private sealed class MostDependentComparer : IComparer
        {
            /// <summary>
            /// Initializes a new instance of the MostDependentComparer class
            /// </summary>
            public MostDependentComparer() 
            {
            
            }

            #region IComparer Members

            /// <summary>
            /// Compares two PluginDescriptor instances.
            /// </summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <returns></returns>
            public int Compare(object x, object y)
            {
                PluginDescriptor xDescriptor = (PluginDescriptor)x;
                PluginDescriptor yDescriptor = (PluginDescriptor)y;

                if (xDescriptor == yDescriptor)
                    return 0;

                // the opposite of the LeastDependentComparer class
                bool xDependsOnY = xDescriptor.DependsOn(yDescriptor);
                bool yDependsOnX = yDescriptor.DependsOn(xDescriptor);

                if (xDependsOnY)
                    return -1;
                else if (yDependsOnX)
                    return 1;
                else
                    return 0;
            }

            #endregion

        }

        #endregion

		/// <summary>
		/// Initializes a new instance of the PluginDescriptorCollection class
		/// </summary>
		internal PluginDescriptorCollection()
		{
			
		}

		/// <summary>
		/// Adds a PluginDescriptor to the collection.
		/// </summary>
		/// <param name="descriptor">The descriptor to add to the collection</param>
		internal void Add(PluginDescriptor descriptor)
		{
			if (this.Contains(descriptor))
				throw new PluginDescriptorAlreadyExistsException(descriptor);

			lock (base.SyncRoot)
			{
				base.InnerList.Add(descriptor);
			}
		}

		/// <summary>
		/// Adds an array of plugin descriptors to the collection.
		/// </summary>
		/// <param name="descriptors">The array of descriptors to add.</param>
		internal void Add(PluginDescriptor[] descriptors)
		{
			if (descriptors == null)
				throw new ArgumentNullException("descriptors");

			foreach (PluginDescriptor descriptor in descriptors)
			{
				this.Add(descriptor);
			}
		}

		/// <summary>
		/// Determines if the collection contains a PluginDescriptor to the same Type as the one specified.
		/// </summary>
		/// <param name="descriptor">The PluginDescriptor to check for</param>
		/// <returns></returns>
		public bool Contains(PluginDescriptor descriptor)
		{
			if (descriptor == null)
				throw new ArgumentNullException("descriptor");
			return (this[descriptor.PluginType] != null);
		}

        /// <summary>
        /// Sorts the collection of descriptors.
        /// </summary>
        /// <param name="leastDependentFirst">A flag that if true sorts the collection placing descriptors with the least
        /// number of dependencies first, false places the descriptors with the most dependencies first.</param>
        public void Sort(bool leastDependentFirst)
        {
            // use our custom comparers to sort based on dependencies
            IComparer comparer = null;
            
            if (leastDependentFirst)
                comparer = new LeastDependentComparer();
            else
                comparer = new MostDependentComparer();                       

            this.Sort(comparer);

            this.LogContents();
        }

		/// <summary>
		/// Returns the PluginDescriptor from the collection that contains the Type specified.
		/// </summary>
		/// <param name="pluginTypeFullName">The Type to look for</param>
		public PluginDescriptor this[Type pluginType]
		{
			get
			{
				lock (base.SyncRoot)
				{
					foreach (PluginDescriptor descriptor in base.InnerList)
					{
						if (descriptor.PluginType == pluginType)
							return descriptor;
					}
					return null;
				}				
			}
		}

		/// <summary>
		/// Returns the PluginDescriptor from the collection that contains the Type specified.
		/// </summary>
		/// <param name="pluginTypeFullName">The full Type name of the Type to look for</param>
		public PluginDescriptor this[string pluginTypeFullName]
		{
			get
			{
				lock (base.SyncRoot)
				{
					foreach (PluginDescriptor descriptor in base.InnerList)
					{
						if (string.Compare(descriptor.PluginType.FullName, pluginTypeFullName, true) == 0)
							return descriptor;
					}
					return null;
				}
			}
		}

		internal new void Clear()
		{
			lock (base.SyncRoot)
			{
				base.InnerList.Clear();
			}
		}

		/// <summary>
		/// Returns the contents of the collection as a PluginDescriptor array.
		/// </summary>
		/// <returns></returns>
		internal PluginDescriptor[] ToArray()
		{
			lock (base.SyncRoot)
			{
				return base.InnerList.ToArray(typeof(PluginDescriptor)) as PluginDescriptor[];
			}
		}

        /// <summary>
        /// Writes the names of each PluginDescriptor contained in the collection to the Log object.
        /// </summary>
        /// <returns></returns>
        internal void LogContents()
        {            
            try
            {
                Log.WriteLine("PluginDescriptorCollection Contents :");            
                Log.Indent();

                foreach (PluginDescriptor descriptor in base.InnerList)
                    Log.WriteLine("PluginDescriptor: '{0}', Status: '{1}'", descriptor.PluginName, descriptor.IsStartable ? "Startable" : "Unstartable");
            }
            catch(Exception ex)
            {
                Log.WriteLine(ex);
            }
            finally
            {
                Log.Unindent();
            }
        }
	}
}
